import{toNestErrors as r}from"@hookform/resolvers";import{parse as t,parseAsync as e,ValiError as n}from"valibot";import{appendErrors as o}from"react-hook-form";function a(r,t){(null==t||t>r.length)&&(t=r.length);for(var e=0,n=new Array(t);e<t;e++)n[e]=r[e];return n}var i=function(r,t){for(var e,n={},i=function(r,t){var e="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(e)return(e=e.call(r)).next.bind(e);if(Array.isArray(r)||(e=function(r,t){if(r){if("string"==typeof r)return a(r,t);var e=Object.prototype.toString.call(r).slice(8,-1);return"Object"===e&&r.constructor&&(e=r.constructor.name),"Map"===e||"Set"===e?Array.from(r):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?a(r,t):void 0}}(r))){e&&(r=e);var n=0;return function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(r.issues);!(e=i()).done;){var u=e.value;if(u.path){var s=u.path.map(function(r){return r.key}).join(".");if(n[s]||(n[s]={message:u.message,type:u.validation}),t){var c=n[s].types,l=c&&c[u.validation];n[s]=o(s,t,n,u.validation,l?[].concat(l,u.message):u.message)}}}return n},u=function(o,a,u){return void 0===u&&(u={}),function(s,c,l){try{return Promise.resolve(function(r,n){try{var i=function(){function r(r){return{values:u.raw?s:r,errors:{}}}var n=Object.assign({},{abortEarly:!1,abortPipeEarly:!1},a);return"sync"===u.mode?r(t(o,s,n)):Promise.resolve(e(o,s,n)).then(r)}()}catch(r){return n(r)}return i&&i.then?i.then(void 0,n):i}(0,function(t){if(t instanceof n)return{values:{},errors:r(i(t,!l.shouldUseNativeValidation&&"all"===l.criteriaMode),l)};throw t}))}catch(r){return Promise.reject(r)}}};export{u as valibotResolver};
//# sourceMappingURL=valibot.module.js.map
